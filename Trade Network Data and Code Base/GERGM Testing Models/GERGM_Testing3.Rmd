

```{r}
#Install all packages before running
#install.packages(c("here", "readr", "readxl", "data.table", "snafun", "igraph", "gergm"))
#remotes::install_github("matthewjdenny/GERGM",
#dependencies = TRUE, force = TRUE)
```
# This model Categorize governance measures into five ordered groups, because they all have value from -2.5-> 2.5. So / to 5 intervals and set 5 categories correspondingly

```{r}
# Import all datasets
trade_data <- readxl::read_excel("trade_1988_2021.xlsx")
wb1 <- readxl::read_excel("P_Data_Extract_From_Doing_Business.xlsx")
wb2 <- readxl::read_excel("P_Data_Extract_From_World_Development_Indicators.xlsx")
wb3 <- readxl::read_excel("P_Data_Extract_From_Worldwide_Governance_Indicators.xlsx")

# Convert to data.table for manipulation
trade_data <- data.table::as.data.table(trade_data)
wb1 <- data.table::as.data.table(wb1)
wb2 <- data.table::as.data.table(wb2)
wb3 <- data.table::as.data.table(wb3)
```

```{r}
# Select only 2018
trade_data_2018 <- trade_data[
  Year == 2018 &
    !ReporterName %in% c("Other Asia, nes", "World", "European Union") &
    !PartnerName %in% c("Other Asia, nes", "World", "European Union") &
    `TradeValue in 1000 USD` > 0
]
```

```{r}
# Clean Doing Business Data with data.table
wb1 <- data.table::setnames(wb1, old = names(wb1), new = make.names(names(wb1)))
names(wb1)
wb1 <- wb1[, .(
  time = Time,
  time_code = Time.Code,
  category = Category,
  country_name = Country.Name,
  country_code = Country.Code,

  # Export times
  export_border_time_hrs = Time.to.export..Border.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.EXPT.BRDR.COMP.HR.DB1619.,
  export_doc_time_hrs = Time.to.export..Documentary.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.DOC.COMP.HR.DB1619.,

  # Import times
  import_border_time_hrs = Time.to.import..Border.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.IMP.BRDR.COMP.HR.DB1619.,
  import_doc_time_hrs = Time.to.import..Documentary.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.IMP.DOC.COMP.HR.DB1619.,

  # Export costs
  export_border_cost_usd = Trading.across.borders..Cost.to.export..Border.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.EXPT.COST.BRDR.COMP.CD.DB1619.,
  export_border_cost_score = Trading.across.borders..Cost.to.export..Border.compliance..USD...DB16.20.methodology....Score..TRD.ACRS.BRDR.EXPT.COST.BRDR.COMP.CD.DB1619.DFRN.,
  export_doc_cost_usd = Trading.across.borders..Cost.to.export..Documentary.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.EXPT.COST.DOC.COMP.CD.DB1619.,

  # Import costs
  import_border_cost_usd = Trading.across.borders..Cost.to.import..Border.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.IMP.COST.BRDR.COMP.CD.DB1619.,
  import_border_cost_score = Trading.across.borders..Cost.to.import..Border.compliance..USD...DB16.20.methodology....Score..TRD.ACRS.BRDR.IMP.COST.BRDR.COMP.CD.DB1619.DFRN.,
  import_doc_cost_usd = Trading.across.borders..Cost.to.import..Documentary.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.IMP.COST.DOC.COMP.CD.DB1619.,
  import_doc_cost_score = Trading.across.borders..Cost.to.import..Documentary.compliance..USD...DB16.20.methodology....Score..TRD.ACRS.BRDR.IMP.COST.DOC.COMP.CD.DB1619.DFRN.,

  # Scores
  trading_score = Trading.across.borders..DB16.20.methodology....Score..TRD.ACRS.BRDR.DB1619.DFRN.,
  import_border_time_score = Trading.across.borders..Time.to.import..Border.compliance..hours...DB16.20.methodology....Score..TRD.ACRS.BRDR.IMP.TM.BRDR.COMP.HR.DB1619.DFRN.,
  import_doc_time_score = Trading.across.borders..Time.to.import..Documentary.compliance..hours...DB16.20.methodology....Score..TRD.ACRS.BRDR.IMP.TM.DOC.COMP.HR.DB1619.DFRN.
)]
```

```{r}
#Rename and clean economic indicators
wb2 <- data.table::setnames(wb2, old = names(wb2), new = make.names(names(wb2)))

# Select and rename relevant columns
wb2 <- wb2[, .(
  time = Time,
  time_code = Time.Code,
  country_name = Country.Name,
  country_code = Country.Code,
  inflation_rate = Inflation..consumer.prices..annual.....FP.CPI.TOTL.ZG.,
  gdp_growth = GDP.growth..annual.....NY.GDP.MKTP.KD.ZG.,
  gdp_current_usd = GDP..current.US....NY.GDP.MKTP.CD.
)]
```

```{r}
#Rename and clean Governance Indicator
wb3 <- data.table::setnames(wb3, old = names(wb3), new = make.names(names(wb3)))

# Select and rename relevant columns
wb3 <- wb3[, .(
  time = Time,
  time_code = Time.Code,
  country_name = Country.Name,
  country_code = Country.Code,
  gov_effectiveness = Government.Effectiveness..Estimate..GE.EST.,
  regulatory_quality = Regulatory.Quality..Estimate..RQ.EST.,
  control_corruption = Control.of.Corruption..Estimate..CC.EST.,
  rule_of_law = Rule.of.Law..Estimate..RL.EST.
)]

```

```{r}
# Unique Country Codes for every dataset
length(unique(trade_data_2018$ReporterISO3))
length(unique(wb1$country_code))
length(unique(wb2$country_code))
length(unique(wb3$country_code))

wb_combined <- merge(wb1, wb2, by = "country_code", all = FALSE)
wb_combined <- merge(wb_combined, wb3, by = "country_code", all = FALSE)
wb_combined <- unique(wb_combined, by = "country_code")

length(unique(wb_combined$country_code))
```

```{r}
# Keep only countries that appear in trade data (reporter or partner)
trade_countries <- unique(c(trade_data_2018$ReporterISO3, trade_data_2018$PartnerISO3))
wb_combined <- wb_combined[country_code %in% trade_countries]
```

```{r}
# Remove duplicate columns - keep only one version of time, time_code, and country_name
wb_combined <- wb_combined[, .(
  country_code,
  export_border_time_hrs,
  import_border_time_hrs,
  trading_score,
  export_doc_time_hrs,
  import_doc_time_hrs,
  export_border_cost_usd,
  export_border_cost_score,
  export_doc_cost_usd,
  import_border_cost_usd,
  import_border_cost_score,
  import_doc_cost_usd,
  import_doc_cost_score,
  import_border_time_score,
  import_doc_time_score,
  inflation_rate,
  gdp_growth,
  gdp_current_usd,
  gov_effectiveness,
  regulatory_quality,
  control_corruption,
  rule_of_law
)]
```

```{r}
# Check the cleaned column names
colnames(wb_combined)
length(unique(wb_combined$country_code))

length(unique(wb_combined$country_code))

# Edge List
edge_list <- data.table::data.table(
  from = trade_data_2018$ReporterISO3,
  to = trade_data_2018$PartnerISO3,
  weight = trade_data_2018$`TradeValue in 1000 USD`
)

```
```{r}
#Harmonize edge weights to numeric (handles dotted thousand separators)
edge_list[, weight := readr::parse_number(weight)]
edge_list <- edge_list[!is.na(weight)]

# Vertex Attributes
vertices <- data.table::copy(wb_combined)
data.table::setnames(vertices, "country_code", "name")
head(vertices)
dim(vertices) #181 countries

colnames(vertices)
#Convert attributes to Numeric
cols_to_numeric <- setdiff(names(vertices), "name")
vertices[, (cols_to_numeric) := lapply(.SD, as.numeric), .SDcols = cols_to_numeric]

#Keep consistent country nodes
common_countries <- intersect(unique(c(edge_list$from, edge_list$to)), vertices$name)
edge_list <- edge_list[from %in% common_countries & to %in% common_countries]
vertices <- vertices[name %in% common_countries]
```
```{r ensure_vertices, message=FALSE}
# Safety net so downstream GERGM chunks can run independently


if (!exists("vertices")) {
  vertices <- data.table::copy(wb_combined)
  data.table::setnames(vertices, "country_code", "name")
}
```

```{r}
if (!exists("edge_list")) {
  edge_list <- data.table::data.table(
    from = trade_data_2018$ReporterISO3,
    to = trade_data_2018$PartnerISO3,
    weight = trade_data_2018$`TradeValue in 1000 USD`
  )
  edge_list[, weight := readr::parse_number(weight)]
  edge_list <- edge_list[weight > 0 & !is.na(weight)]
}

# Ensure attributes are numeric and aligned to the edge list when re-created
cols_to_numeric <- setdiff(names(vertices), "name")
vertices[, (cols_to_numeric) := lapply(.SD, as.numeric), .SDcols = cols_to_numeric]
common_countries <- intersect(unique(c(edge_list$from, edge_list$to)), vertices$name)
edge_list <- edge_list[from %in% common_countries & to %in% common_countries]
vertices <- vertices[name %in% common_countries]

# Recreate the graph objects if they are missing
if (!exists("trade_graph")) {
  trade_graph <- igraph::graph_from_data_frame(edge_list, directed = TRUE, vertices = vertices)
}

if (!exists("trade_network")) {
  trade_network <- intergraph::asNetwork(trade_graph)
}
```

```{r}
# Prepare covariates for GERGM analysis on the rescaled trade matrix
export_totals <- edge_list[, .(total_exports = sum(weight)), by = from]
import_totals <- edge_list[, .(total_imports = sum(weight)), by = to]

vertices[export_totals, total_exports := i.total_exports, on = .(name = from)]
vertices[import_totals, total_imports := i.total_imports, on = .(name = to)]

vertices[is.na(total_exports), total_exports := 0]
vertices[is.na(total_imports), total_imports := 0]

vertices[, `:=`(
  log_total_exports = log1p(total_exports),
  log_total_imports = log1p(total_imports)
)]

# Keep countries with available inflation for the homophily control
analysis_vertices <- vertices[
  !is.na(inflation_rate) &
    !is.na(gdp_current_usd) &
    !is.na(export_border_time_hrs) &
    !is.na(export_border_cost_usd)
]
analysis_countries <- analysis_vertices$name

trade_graph_sub <- igraph::induced_subgraph(
  trade_graph,
  vids = which(igraph::V(trade_graph)$name %in% analysis_countries)
)

trade_matrix <- igraph::as_adjacency_matrix(
  trade_graph_sub,
  attr = "weight",
  sparse = FALSE
)
trade_matrix <- as.matrix(trade_matrix)
ordered_countries <- rownames(trade_matrix)

analysis_vertices <- analysis_vertices[match(ordered_countries, name)]

max_trade_value <- max(trade_matrix)
trade_matrix_rescaled <- if (max_trade_value > 0) {
  trade_matrix / max_trade_value
} else {
  trade_matrix
}
diag(trade_matrix_rescaled) <- 0

infl_values <- analysis_vertices$inflation_rate
AbsDiffInfl <- abs(outer(infl_values, infl_values, "-"))
max_abs_diff <- max(AbsDiffInfl)
AbsDiffInfl <- if (max_abs_diff > 0) {
  AbsDiffInfl / max_abs_diff
} else {
  AbsDiffInfl
}
dimnames(AbsDiffInfl) <- list(ordered_countries, ordered_countries)

covariate_data <- as.data.frame(analysis_vertices[, .(
  name,
  log_total_exports,
  log_total_imports,
  inflation_rate,
  log_gdp_usd = log1p(gdp_current_usd),
  export_border_time_hrs,
  log_export_border_cost = log1p(export_border_cost_usd)
)])
row.names(covariate_data) <- covariate_data$name
```

```{r}
trade_formula <- trade_matrix_rescaled ~ edges +
  sender("log_total_exports") +
  receiver("log_total_imports") +
  sender("inflation_rate") +
  receiver("inflation_rate") +
  sender("log_gdp_usd") +
  receiver("log_gdp_usd") 

set.seed(123)
gergm_results <- GERGM::gergm(
  trade_formula,
  covariate_data = covariate_data,
  covariate_networks = list(AbsDiffInfl = AbsDiffInfl),
  number_of_networks_to_simulate = 20000,
  MCMC_burnin = 5000,
  thin = 1/10,
  transformation_type = "Cauchy",
  parallel = FALSE
)
```


```{r}
category_breaks <- seq(-2.5, 2.5, length.out = 6)
categorize_attribute <- function(x) {
  cut(x, breaks = category_breaks, labels = 1:5, include.lowest = TRUE, right = TRUE)
}

vertices[, `:=`(
  gov_effectiveness_cat = factor(categorize_attribute(gov_effectiveness), levels = 1:5, ordered = TRUE),
  regulatory_quality_cat = factor(categorize_attribute(regulatory_quality), levels = 1:5, ordered = TRUE),
  control_corruption_cat = factor(categorize_attribute(control_corruption), levels = 1:5, ordered = TRUE),
  rule_of_law_cat = factor(categorize_attribute(rule_of_law), levels = 1:5, ordered = TRUE)
)]
```

```{r gergm_research_question_2, message=FALSE, warning=FALSE}
# Recompute exporter/importer totals to align with governance categories

# Categorize governance measures into five ordered groups, because they all have value from -2.5-> 2.5. So / to 5 intervals and set 5 categories correspondingly

rq2_export_totals <- edge_list[, .(total_exports = sum(weight)), by = from]
rq2_import_totals <- edge_list[, .(total_imports = sum(weight)), by = to]

vertices[rq2_export_totals, total_exports := i.total_exports, on = .(name = from)]
vertices[rq2_import_totals, total_imports := i.total_imports, on = .(name = to)]
vertices[is.na(total_exports), total_exports := 0]
vertices[is.na(total_imports), total_imports := 0]

vertices[, `:=`(
  log_total_exports = log1p(total_exports),
  log_total_imports = log1p(total_imports),
  log_gdp_usd = log1p(gdp_current_usd),
  log_export_border_cost = log1p(export_border_cost_usd)
)]

# Filter to cases with all required covariates and governance categories
rq2_vertices <- vertices[
  !is.na(inflation_rate) & !is.na(log_gdp_usd) &
    !is.na(export_border_time_hrs) & !is.na(log_export_border_cost) &
    !is.na(gov_effectiveness_cat) & !is.na(regulatory_quality_cat) &
    !is.na(control_corruption_cat) & !is.na(rule_of_law_cat)
]
rq2_countries <- rq2_vertices$name

trade_graph_rq2 <- igraph::induced_subgraph(
  trade_graph,
  vids = which(igraph::V(trade_graph)$name %in% rq2_countries)
)

trade_matrix_rq2 <- igraph::as_adjacency_matrix(trade_graph_rq2, attr = "weight", sparse = FALSE)
trade_matrix_rq2 <- as.matrix(trade_matrix_rq2)
ordered_rq2 <- rownames(trade_matrix_rq2)
rq2_vertices <- rq2_vertices[match(ordered_rq2, name)]

max_trade_rq2 <- max(trade_matrix_rq2)
trade_matrix_rescaled_rq2 <- if (max_trade_rq2 > 0) trade_matrix_rq2 / max_trade_rq2 else trade_matrix_rq2
diag(trade_matrix_rescaled_rq2) <- 0

# Inflation homophily control (rescaled absolute differences)
rq2_infl <- rq2_vertices$inflation_rate
AbsDiffInfl_rq2 <- abs(outer(rq2_infl, rq2_infl, "-"))
max_abs_diff_rq2 <- max(AbsDiffInfl_rq2)
AbsDiffInfl_rq2 <- if (max_abs_diff_rq2 > 0) AbsDiffInfl_rq2 / max_abs_diff_rq2 else AbsDiffInfl_rq2
dimnames(AbsDiffInfl_rq2) <- list(ordered_rq2, ordered_rq2)

# Create a dataframe of all vertices attribute, GERGM takes dataframe/vector of the attribute, I've just added export_border_time and cost to test, but export_border_time_hrs, log_export_border_cost not in the theory
rq2_covariate_data <- as.data.frame(rq2_vertices[, .(
  name,
  log_total_exports,
  log_total_imports,
  inflation_rate,
  log_gdp_usd,
  export_border_time_hrs,
  log_export_border_cost,
  gov_effectiveness_cat,
  regulatory_quality_cat,
  control_corruption_cat,
  rule_of_law_cat
)])

# This code to avoid error caused by infinite value of the vertice attributes above when running model
row.names(rq2_covariate_data) <- rq2_covariate_data$name
na_counts <- sapply(vertices, function(x) sum(!is.finite(x)))
print(na_counts)
```


```{r}
rq2_formula <- trade_matrix_rescaled_rq2 ~ edges +
  sender("log_gdp_usd") +
  receiver("log_gdp_usd") +
  nodematch("regulatory_quality_cat")  + mutual(alpha = 0.03)

set.seed(1234)
gergm_rq2 <- GERGM::gergm(
  rq2_formula,
  covariate_data = rq2_covariate_data,
  number_of_networks_to_simulate = 100000,
  MCMC_burnin = 15000,
  thin = 1/10,
  transformation_type = "Cauchy",
  parallel = TRUE,
  seed_network = trade_matrix_rescaled_rq2,
  cores = 7
)
```

