---
title: "GERGM Models for Research Question 2"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(data.table)
library(readr)
library(readxl)
library(igraph)
library(intergraph)
library(GERGM)
```

## Data preparation

```{r load_data}
# Import all datasets
trade_data <- readxl::read_excel("trade_1988_2021.xlsx")
wb1 <- readxl::read_excel("P_Data_Extract_From_Doing_Business.xlsx")
wb2 <- readxl::read_excel("P_Data_Extract_From_World_Development_Indicators.xlsx")
wb3 <- readxl::read_excel("P_Data_Extract_From_Worldwide_Governance_Indicators.xlsx")

# Convert to data.table for manipulation
trade_data <- as.data.table(trade_data)
wb1 <- as.data.table(wb1)
wb2 <- as.data.table(wb2)
wb3 <- as.data.table(wb3)
```

```{r filter_trade}
# Select only 2018 observations with valid partners
trade_data_2018 <- trade_data[
  Year == 2018 &
    !ReporterName %in% c("Other Asia, nes", "World", "European Union") &
    !PartnerName %in% c("Other Asia, nes", "World", "European Union") &
    `TradeValue in 1000 USD` > 0
]
```

```{r clean_doing_business}
# Clean Doing Business data
wb1 <- setnames(wb1, old = names(wb1), new = make.names(names(wb1)))
wb1 <- wb1[, .(
  country_code = Country.Code,
  export_border_time_hrs = Time.to.export..Border.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.EXPT.BRDR.COMP.HR.DB1619.,
  export_border_cost_usd = Trading.across.borders..Cost.to.export..Border.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.EXPT.COST.BRDR.COMP.CD.DB1619.,
  export_doc_time_hrs = Time.to.export..Documentary.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.DOC.COMP.HR.DB1619.,
  import_border_time_hrs = Time.to.import..Border.compliance..hours...DB16.20.methodology...TRD.ACRS.BRDR.IMP.BRDR.COMP.HR.DB1619.,
  import_border_cost_usd = Trading.across.borders..Cost.to.import..Border.compliance..USD...DB16.20.methodology...TRD.ACRS.BRDR.IMP.COST.BRDR.COMP.CD.DB1619.
)]
```

```{r clean_wdi}
# Clean macro indicators
wb2 <- setnames(wb2, old = names(wb2), new = make.names(names(wb2)))
wb2 <- wb2[, .(
  country_code = Country.Code,
  inflation_rate = Inflation..consumer.prices..annual.....FP.CPI.TOTL.ZG.,
  gdp_current_usd = GDP..current.US....NY.GDP.MKTP.CD.
)]
```

```{r clean_wgi}
# Clean governance indicators
wb3 <- setnames(wb3, old = names(wb3), new = make.names(names(wb3)))
wb3 <- wb3[, .(
  country_code = Country.Code,
  gov_effectiveness = Government.Effectiveness..Estimate..GE.EST.,
  regulatory_quality = Regulatory.Quality..Estimate..RQ.EST.,
  control_corruption = Control.of.Corruption..Estimate..CC.EST.,
  rule_of_law = Rule.of.Law..Estimate..RL.EST.
)]
```

```{r merge_attributes}
# Merge attribute tables and keep countries observed in trade data
wb_combined <- merge(wb1, wb2, by = "country_code", all = FALSE)
wb_combined <- merge(wb_combined, wb3, by = "country_code", all = FALSE)
wb_combined <- unique(wb_combined, by = "country_code")

trade_countries <- unique(c(trade_data_2018$ReporterISO3, trade_data_2018$PartnerISO3))
wb_combined <- wb_combined[country_code %in% trade_countries]
```

```{r build_edges_vertices}
# Edge list with numeric weights
edge_list <- data.table(
from = trade_data_2018$ReporterISO3,
to = trade_data_2018$PartnerISO3,
weight = trade_data_2018$`TradeValue in 1000 USD`
)

edge_list[, weight := readr::parse_number(weight)]
edge_list <- edge_list[weight > 0 & !is.na(weight)]

# Vertices

vertices <- copy(wb_combined)
setnames(vertices, "country_code", "name")

# Convert to numeric 
cols_to_numeric <- setdiff(names(vertices), "name")
vertices[, (cols_to_numeric) := lapply(.SD, readr::parse_number), .SDcols = cols_to_numeric]


common_countries <- intersect(unique(c(edge_list$from, edge_list$to)), vertices$name)
edge_list <- edge_list[from %in% common_countries & to %in% common_countries]
vertices <- vertices[name %in% common_countries]
```

```{r trade_network}
# Build network objects
trade_graph <- igraph::graph_from_data_frame(edge_list, directed = TRUE, vertices = vertices)
trade_network <- intergraph::asNetwork(trade_graph)
```

```{r derived_measures}
# Exporter/importer totals and logs

export_totals <- edge_list[, .(total_exports = sum(weight)), by = from]
import_totals <- edge_list[, .(total_imports = sum(weight)), by = to]

vertices[export_totals, total_exports := i.total_exports, on = .(name = from)]
vertices[import_totals, total_imports := i.total_imports, on = .(name = to)]

vertices[is.na(total_exports), total_exports := 0]
vertices[is.na(total_imports), total_imports := 0]

# Normalization with log
vertices[, `:=`(
log_total_exports = log1p(total_exports),
log_total_imports = log1p(total_imports),
log_gdp_usd = log1p(gdp_current_usd),
log_export_border_cost = log1p(export_border_cost_usd)
)]



```

```{r governance_categories}
# Categorize governance measures into five ordered groups, because they all have value from -2.5-> 2.5. So / to 5 intervals and set 5 categories
category_breaks <- seq(-2.5, 2.5, length.out = 6)
categorize_attribute <- function(x) {
cut(x, breaks = category_breaks, labels = 1:5, include.lowest = TRUE, right = TRUE)
}

vertices[, `:=`(
gov_effectiveness_cat = categorize_attribute(gov_effectiveness),
regulatory_quality_cat = categorize_attribute(regulatory_quality),
control_corruption_cat = categorize_attribute(control_corruption),
rule_of_law_cat = categorize_attribute(rule_of_law)
)]
```

```{r analysis_subset}
# Restrict to countries with complete covariate coverage
analysis_vertices <- vertices[
!is.na(inflation_rate) &
!is.na(log_gdp_usd) &
!is.na(export_border_time_hrs) &
!is.na(log_export_border_cost) &
!is.na(regulatory_quality_cat) &
!is.na(rule_of_law_cat) &
!is.na(gov_effectiveness_cat) &
!is.na(control_corruption_cat)
]

analysis_countries <- analysis_vertices$name


trade_graph_sub <- igraph::induced_subgraph(
trade_graph,
vids = which(igraph::V(trade_graph)$name %in% analysis_countries)
)

# Create adjacency matrix
trade_matrix <- igraph::as_adjacency_matrix(
trade_graph_sub,
attr = "weight",
sparse = FALSE
)
trade_matrix <- as.matrix(trade_matrix)
trade_matrix[is.na(trade_matrix)] <- 0
diag(trade_matrix) <- 0 # no self-loops

ordered_countries <- rownames(trade_matrix)


analysis_vertices <- analysis_vertices[match(ordered_countries, name)]

```

```{r}
infl_values <- analysis_vertices$inflation_rate
AbsDiffInfl <- abs(outer(infl_values, infl_values, "-"))
max_abs_diff <- max(AbsDiffInfl)
AbsDiffInfl <- if (max_abs_diff > 0) AbsDiffInfl / max_abs_diff else AbsDiffInfl
dimnames(AbsDiffInfl) <- list(ordered_countries, ordered_countries)

covariate_data <- as.data.frame(analysis_vertices[, .(
name,
log_total_exports,
log_total_imports,
inflation_rate,
log_gdp_usd,
export_border_time_hrs,
log_export_border_cost,
gov_effectiveness_cat,
regulatory_quality_cat,
control_corruption_cat,
rule_of_law_cat
)])
row.names(covariate_data) <- covariate_data$name



```

```{r}
is_num   <- sapply(covariate_data, is.numeric)
num_cols <- names(covariate_data)[is_num]  # only numeric columns

cov_numeric <- covariate_data[ , num_cols, drop = FALSE]

# Now check for NA / NaN / Inf only in numeric columns
bad_rows <- apply(as.matrix(cov_numeric), 1, function(z) any(!is.finite(z)))

# How many rows will we drop?
sum(bad_rows)

```


```{r}
any(!is.finite(trade_matrix))                   # should be FALSE
cov_numeric <- covariate_data[ , sapply(covariate_data, is.numeric), drop = FALSE]
any(!is.finite(as.matrix(cov_numeric)))         # should now be FALSE

identical(rownames(trade_matrix), rownames(covariate_data))  # should be TRUE

str(covariate_data$regulatory_quality_cat)
str(covariate_data$rule_of_law_cat)
# First, make sure your network and attribute data are in the same order
stopifnot(identical(ordered_countries, rownames(trade_matrix)))

# Build a *fresh* covariate_data from analysis_vertices in that same order:
covariate_data <- data.frame(
  regulatory_quality_cat = as.factor(analysis_vertices$regulatory_quality_cat),
  rule_of_law_cat        = as.factor(analysis_vertices$rule_of_law_cat),
  log_total_exports      = analysis_vertices$log_total_exports,
  log_total_imports      = analysis_vertices$log_total_imports,
  inflation_rate         = analysis_vertices$inflation_rate,
  log_gdp_usd            = analysis_vertices$log_gdp_usd,
  export_border_time_hrs = analysis_vertices$export_border_time_hrs,
  log_export_border_cost = analysis_vertices$log_export_border_cost,
  row.names              = analysis_vertices$name
)

# Force super-clean column names:
colnames(covariate_data) <- tolower(trimws(colnames(covariate_data)))

# Sanity check: GERGM will look for exactly these names
print(colnames(covariate_data))

```

## Baseline GERGM (exogenous structure only)

```{r baseline_model}

baseline_formula <- trade_matrix_rescaled ~ 
  edges + 
  nodematch("regulatory_quality_cat") +
  nodematch("rule_of_law_cat") +
  mutual(alpha = 0.05)
set.seed(12)


```
```{r}
# Run the baseline model

baseline_gergm <- GERGM::gergm(
  formula                         = baseline_formula,
  covariate_data                  = covariate_data,,
  transformation_type             = "Cauchy",
  number_of_networks_to_simulate  = 5000,
  MCMC_burnin                     = 1000,
  thin                            = 1/10,
  proposal_variance               = 0.05,   # smaller proposal if acceptance is too low
  target_accept_rate              = 0.25,
  sample_edges_at_a_time          = 500,    # try block updates if network is big
  hyperparameter_optimization     = FALSE,
  parallel                        = FALSE,
  cores = 6
  
)

GERGM::Trace_Plot(baseline_gergm)
GERGM::Estimate_Plot(baseline_gergm)
GERGM::GOF_Plot(baseline_gergm)

```


## Extended GERGM (governance similarity and dependence)

```{r extended_model}
extended_formula1 <- trade_matrix_rescaled ~ edges +
  nodematch("regulatory_quality_cat") +
  nodematch("rule_of_law_cat") +
  sender("inflation_rate") + receiver("inflation_rate") +
  sender("log_gdp_usd") + receiver("log_gdp_usd") +
  sender("export_border_time_hrs") + receiver("export_border_time_hrs") +
  mutual(alpha = 0.05) + ttriads(alpha = 0.05)
    

set.seed(12)
extended_gergm1 <- GERGM::gergm(
  extended_formula1,
  covariate_data = covariate_data,
  number_of_networks_to_simulate = 100000,
  number_of_networks_to_simulate = 100000,
  MCMC_burnin = 8000,
  thin = 1/10,
  transformation_type = "Cauchy",
  weighted_MPLE = TRUE,
  seed_network = trade_matrix_rescaled,
  hyperparameter_optimization = TRUE,
  parallel = TRUE, 
  cores = 10

)
```

```{r}
extended_formula2 <- trade_matrix_rescaled ~ edges +
  nodematch("regulatory_quality_cat") +
  nodematch("rule_of_law_cat") +
  sender("inflation_rate") + receiver("inflation_rate") +
  sender("log_gdp_usd") + receiver("log_gdp_usd") +
  sender("export_border_time_hrs") + receiver("export_border_time_hrs") +
  mutual(alpha = 0.05) + ttriads(alpha = 0.05)

set.seed(12)


extended_gergm <- GERGM::gergm(
  extended_formula2,
  covariate_data = covariate_data,
  number_of_networks_to_simulate = 100000,
  number_of_networks_to_simulate = 100000,
  MCMC_burnin = 8000,
  thin = 1/10,
  transformation_type = "Cauchy",
  weighted_MPLE = FALSE,
  seed_network = trade_matrix_rescaled,
  hyperparameter_optimization = TRUE,
  parallel = TRUE, 
  cores = 10
)


```


## Results and diagnostics

```{r compare_estimates}
baseline_theta <- data.table(
  term = rownames(attributes(baseline_gergm)$theta.coef),
  estimate = attributes(baseline_gergm)$theta.coef[, "est"],
  se = attributes(baseline_gergm)$theta.coef[, "se"],
  model = "Baseline"
)

extended_theta <- data.table(
  term = rownames(attributes(extended_gergm)$theta.coef),
  estimate = attributes(extended_gergm)$theta.coef[, "est"],
  se = attributes(extended_gergm)$theta.coef[, "se"],
  model = "Extended"
)

rbind(baseline_theta, extended_theta)
```


```{r}
library(GERGM)
?gergm
help(package = "GERGM")
browseVignettes("GERGM")
```
